
// builtinDatastore creates a thread-safe namespaced key/value store
func (b *Builtins) builtinDatastore(evaluator *Evaluator, args map[string]any) (any, error) {
	// Get namespace from first positional or named argument
	var namespace string

	if ns, ok := args["0"]; ok {
		// Positional argument
		namespace = fmt.Sprintf("%v", ns)
	} else if ns, ok := args["namespace"]; ok {
		// Named argument
		namespace = fmt.Sprintf("%v", ns)
	} else {
		return nil, fmt.Errorf("datastore() requires a namespace argument")
	}

	// Get config from second positional or named argument (optional)
	var config map[string]any

	if cfg, ok := args["1"]; ok {
		// Positional argument
		if cfgMap, ok := cfg.(map[string]any); ok {
			config = cfgMap
		}
	} else if cfg, ok := args["config"]; ok {
		// Named argument
		if cfgMap, ok := cfg.(map[string]any); ok {
			config = cfgMap
		}
	}

	// sys datastore is read-only and rejects any config
	if namespace == "sys" {
		if len(config) > 0 {
			return nil, fmt.Errorf("datastore(\"sys\") does not accept configuration options")
		}
	}

	// Get or create the datastore
	store := GetDatastore(namespace, config)

	// Create set(key, value) method
	setFn := NewGoFunction(func(setEval *Evaluator, setArgs map[string]any) (any, error) {
		if namespace == "sys" {
			return nil, fmt.Errorf("datastore(\"sys\") is read-only")
		}
		key, ok := setArgs["0"].(string)
		if !ok {
			return nil, fmt.Errorf("set() requires key (string) and value arguments")
		}
		value, ok := setArgs["1"]
		if !ok {
			return nil, fmt.Errorf("set() requires key and value arguments")
		}
		return nil, store.Set(key, value)
	})

	// Create get(key) method
	getFn := NewGoFunction(func(getEval *Evaluator, getArgs map[string]any) (any, error) {
		key, ok := getArgs["0"].(string)
		if !ok {
			return nil, fmt.Errorf("get() requires a key (string) argument")
		}
		return store.Get(key)
	})

	// Create increment(key, delta) method
	incrementFn := NewGoFunction(func(incEval *Evaluator, incArgs map[string]any) (any, error) {
		if namespace == "sys" {
			return nil, fmt.Errorf("datastore(\"sys\") is read-only")
		}
		key, ok := incArgs["0"].(string)
		if !ok {
			return nil, fmt.Errorf("increment() requires key (string) and delta arguments")
		}
		delta, ok := incArgs["1"].(float64)
		if !ok {
			return nil, fmt.Errorf("increment() requires a numeric delta argument")
		}
		return store.Increment(key, delta)
	})

	// Create push(key, item) method
	pushFn := NewGoFunction(func(appEval *Evaluator, appArgs map[string]any) (any, error) {
		if namespace == "sys" {
			return nil, fmt.Errorf("datastore(\"sys\") is read-only")
		}
		key, ok := appArgs["0"].(string)
		if !ok {
			return nil, fmt.Errorf("push() requires a key (string) argument")
		}
		item, ok := appArgs["1"]
		if !ok {
			return nil, fmt.Errorf("push() requires an item argument")
		}
		return store.Push(key, item)
	})

	// Create wait(key [, expectedValue]) method
	waitFn := NewGoFunction(func(waitEval *Evaluator, waitArgs map[string]any) (any, error) {
		key, ok := waitArgs["0"].(string)
		if !ok {
			return nil, fmt.Errorf("wait() requires a key (string) argument")
		}

		// Check if expectedValue provided
		expectedValue, hasExpectedValue := waitArgs["1"]

		// Check for timeout (optional)
		timeout := time.Duration(0)
		if timeoutArg, ok := waitArgs["2"]; ok {
			if timeoutSecs, ok := timeoutArg.(float64); ok {
				timeout = time.Duration(timeoutSecs) * time.Second
			}
		} else if timeoutArg, ok := waitArgs["timeout"]; ok {
			if timeoutSecs, ok := timeoutArg.(float64); ok {
				timeout = time.Duration(timeoutSecs) * time.Second
			}
		}

		value, err := store.Wait(key, expectedValue, hasExpectedValue, timeout)
		return value, err
	})

	// Create wait_for(key, predicate [, timeout]) method
	waitForFn := NewGoFunction(func(wfEval *Evaluator, wfArgs map[string]any) (any, error) {
		key, ok := wfArgs["0"].(string)
		if !ok {
			return nil, fmt.Errorf("wait_for() requires a key (string) argument")
		}

		predicateArg, ok := wfArgs["1"]
		if !ok {
			return nil, fmt.Errorf("wait_for() requires a predicate function argument")
		}

		// Extract GoFunction from the argument
		var predicateFn GoFunction

		if goFn, ok := predicateArg.(GoFunction); ok {
			// Direct GoFunction
			predicateFn = goFn
		} else if vr, ok := predicateArg.(*ValueRef); ok {
			// Wrapped in ValueRef - extract the function
			if vr.Val.IsFunction() {
				if goFn, ok := vr.Val.Data.(GoFunction); ok {
					predicateFn = goFn
				} else {
					return nil, fmt.Errorf("wait_for() predicate must be a Go function")
				}
			} else {
				return nil, fmt.Errorf("wait_for() predicate must be a function")
			}
		} else {
			return nil, fmt.Errorf("wait_for() predicate must be a function")
		}

		// Check for timeout (optional)
		timeout := time.Duration(0)
		if timeoutArg, ok := wfArgs["2"]; ok {
			if timeoutSecs, ok := timeoutArg.(float64); ok {
				timeout = time.Duration(timeoutSecs) * time.Second
			}
		} else if timeoutArg, ok := wfArgs["timeout"]; ok {
			if timeoutSecs, ok := timeoutArg.(float64); ok {
				timeout = time.Duration(timeoutSecs) * time.Second
			}
		}

		value, err := store.WaitFor(wfEval, key, predicateFn, timeout)
		return value, err
	})

	// Create delete(key) method
	deleteFn := NewGoFunction(func(delEval *Evaluator, delArgs map[string]any) (any, error) {
		if namespace == "sys" {
			return nil, fmt.Errorf("datastore(\"sys\") is read-only")
		}
		key, ok := delArgs["0"].(string)
		if !ok {
			return nil, fmt.Errorf("delete() requires a key (string) argument")
		}
		return nil, store.Delete(key)
	})

	// Create clear() method
	clearFn := NewGoFunction(func(clearEval *Evaluator, clearArgs map[string]any) (any, error) {
		if namespace == "sys" {
			return nil, fmt.Errorf("datastore(\"sys\") is read-only")
		}
		return nil, store.Clear()
	})

	// Create save() method
	saveFn := NewGoFunction(func(saveEval *Evaluator, saveArgs map[string]any) (any, error) {
		if namespace == "sys" {
			return nil, fmt.Errorf("datastore(\"sys\") is read-only")
		}
		return nil, store.Save()
	})

	// Create load() method
	loadFn := NewGoFunction(func(loadEval *Evaluator, loadArgs map[string]any) (any, error) {
		if namespace == "sys" {
			return nil, fmt.Errorf("datastore(\"sys\") is read-only")
		}
		return nil, store.Load()
	})

	// Return store object with methods
	return map[string]any{
		"set":       setFn,
		"get":       getFn,
		"increment": incrementFn,
		"push":      pushFn,
		"wait":      waitFn,
		"wait_for":  waitForFn,
		"delete":    deleteFn,
		"clear":     clearFn,
		"save":      saveFn,
		"load":      loadFn,
	}, nil
}

