package script

import (
	"runtime"
	"sync"
	"sync/atomic"
	"time"
)

// SystemMetrics tracks runtime system-wide metrics
type SystemMetrics struct {
	httpProcs       atomic.Int64          // Total HTTP requests processed
	spawnProcs      atomic.Int64          // Total spawned processes
	runProcs        atomic.Int64          // Total run() calls executed
	peakGoroutines  int64                 // Highest goroutine count reached
	peakHeapAlloc   uint64                // Highest heap allocation reached
	serverStartTime time.Time             // Server startup time
	goroutinesMutex sync.Mutex            // Protect peak goroutines
	heapMutex       sync.Mutex            // Protect peak heap
}

// Global system metrics instance
var sysMetrics = &SystemMetrics{}

// InitSystemMetrics initializes system metrics with server start time
func InitSystemMetrics() {
	sysMetrics.serverStartTime = time.Now()
}

// IncrementHTTPProcs increments the HTTP process counter
func IncrementHTTPProcs() {
	sysMetrics.httpProcs.Add(1)
	updatePeakGoroutines()
}

// IncrementSpawnProcs increments the spawn process counter
func IncrementSpawnProcs() {
	sysMetrics.spawnProcs.Add(1)
	updatePeakGoroutines()
}

// IncrementRunProcs increments the run process counter
func IncrementRunProcs() {
	sysMetrics.runProcs.Add(1)
	updatePeakGoroutines()
}

// UpdatePeakHeapAlloc checks and updates peak heap allocation
func UpdatePeakHeapAlloc() {
	var m runtime.MemStats
	runtime.ReadMemStats(&m)

	if m.Alloc > sysMetrics.peakHeapAlloc {
		sysMetrics.heapMutex.Lock()
		if m.Alloc > sysMetrics.peakHeapAlloc {
			sysMetrics.peakHeapAlloc = m.Alloc
		}
		sysMetrics.heapMutex.Unlock()
	}
}

// updatePeakGoroutines checks current goroutine count and updates peak
func updatePeakGoroutines() {
	current := int64(runtime.NumGoroutine())
	sysMetrics.goroutinesMutex.Lock()
	if current > sysMetrics.peakGoroutines {
		sysMetrics.peakGoroutines = current
	}
	sysMetrics.goroutinesMutex.Unlock()
}

// GetMetric returns a system metric by key (for on-demand stats)
func GetMetric(key string) any {
	switch key {
	case "http_procs":
		return float64(sysMetrics.httpProcs.Load())
	case "spawn_procs":
		return float64(sysMetrics.spawnProcs.Load())
	case "run_procs":
		return float64(sysMetrics.runProcs.Load())
	case "active_goroutines":
		return float64(runtime.NumGoroutine())
	case "peak_goroutines":
		sysMetrics.goroutinesMutex.Lock()
		defer sysMetrics.goroutinesMutex.Unlock()
		return float64(sysMetrics.peakGoroutines)
	case "heap_alloc":
		var m runtime.MemStats
		runtime.ReadMemStats(&m)
		UpdatePeakHeapAlloc()
		return float64(m.Alloc)
	case "total_alloc":
		var m runtime.MemStats
		runtime.ReadMemStats(&m)
		return float64(m.TotalAlloc)
	case "heap_sys":
		var m runtime.MemStats
		runtime.ReadMemStats(&m)
		return float64(m.HeapSys)
	case "num_gc":
		var m runtime.MemStats
		runtime.ReadMemStats(&m)
		return float64(m.NumGC)
	case "peak_heap_alloc":
		sysMetrics.heapMutex.Lock()
		defer sysMetrics.heapMutex.Unlock()
		return float64(sysMetrics.peakHeapAlloc)
	case "server_start":
		return sysMetrics.serverStartTime.Unix()
	case "datastore_count":
		// Import at top of file: "github.com/duso-org/duso/pkg/runtime"
		// We can't import here due to circular dependency, but runtime.GetDatastoreCount is available
		// For now, return 0 as placeholder - this will be fixed when we restructure
		return float64(0)
	}
	return nil
}
